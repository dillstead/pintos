#include "interrupt.h"
#include <inttypes.h>
#include <stdint.h>
#include "intr-stubs.h"
#include "debug.h"
#include "io.h"
#include "lib.h"
#include "mmu.h"
#include "thread.h"
#include "timer.h"

/* Number of x86 interrupts. */
#define INTR_CNT 256

/* The Interrupt Descriptor Table (IDT).  The format is fixed by
   the CPU.  See [IA32-v3] sections 5.10, 5.11, 5.12.1.2. */
static uint64_t idt[INTR_CNT];

/* Interrupt handler functions for each interrupt. */
static intr_handler_func *intr_handlers[INTR_CNT];

/* Names for each interrupt, for debugging purposes. */
static const char *intr_names[INTR_CNT];

/* External interrupts are those generated by devices outside the
   CPU, such as the timer.  External interrupts run with
   interrupts turned off, so they never nest, nor are they ever
   pre-empted.  Handlers for external interrupts also may not
   sleep, although they may invoke intr_yield_on_return() to
   request that a new process be scheduled just before the
   interrupt returns. */
static bool in_external_intr;   /* Are we processing an external interrupt? */
static bool yield_on_return;    /* Should we yield on interrupt return? */

/* Programmable Interrupt Controller helpers. */
static void pic_init (void);
static void pic_end_of_interrupt (int irq);

/* Interrupt Descriptor Table helpers. */
static uint64_t make_intr_gate (void (*) (void), int dpl);
static uint64_t make_trap_gate (void (*) (void), int dpl);

/* Interrupt handlers. */
void intr_handler (struct intr_frame *args);
static intr_handler_func panic NO_RETURN;
static intr_handler_func kill NO_RETURN;

/* Returns the current interrupt status. */
enum intr_level
intr_get_level (void) 
{
  uint32_t flags;
  
  asm ("pushfl; popl %0" : "=g" (flags));

  return flags & FLAG_IF ? INTR_ON : INTR_OFF;
}

/* Enables or disables interrupts as specified by LEVEL and
   returns the previous interrupt status. */
enum intr_level
intr_set_level (enum intr_level level) 
{
  return level == INTR_ON ? intr_enable () : intr_disable ();
}

/* Enables interrupts and returns the previous interrupt status. */
enum intr_level
intr_enable (void) 
{
  enum intr_level old_level = intr_get_level ();
  asm volatile ("sti");
  return old_level;
}

/* Disables interrupts and returns the previous interrupt status. */
enum intr_level
intr_disable (void) 
{
  enum intr_level old_level = intr_get_level ();
  asm volatile ("cli");
  return old_level;
}

/* Initializes the interrupt system. */
void
intr_init (void)
{
  uint64_t idtr_operand;
  int i;

  pic_init ();

  /* Initialize intr_names. */
  for (i = 0; i < INTR_CNT; i++)
    intr_names[i] = "unknown";

  /* Most exceptions require ring 0.
     Exceptions 3, 4, and 5 can be caused by ring 3 directly. */
  intr_register (0, 0, INTR_ON, kill, "#DE Divide Error");
  intr_register (1, 0, INTR_ON, kill, "#DB Debug Exception");
  intr_register (2, 0, INTR_ON, panic, "NMI Interrupt");
  intr_register (3, 3, INTR_ON, kill, "#BP Breakpoint Exception");
  intr_register (4, 3, INTR_ON, kill, "#OF Overflow Exception");
  intr_register (5, 3, INTR_ON, kill, "#BR BOUND Range Exceeded Exception");
  intr_register (6, 0, INTR_ON, kill, "#UD Invalid Opcode Exception");
  intr_register (7, 0, INTR_ON, kill, "#NM Device Not Available Exception");
  intr_register (8, 0, INTR_ON, panic, "#DF Double Fault Exception");
  intr_register (9, 0, INTR_ON, panic, "Coprocessor Segment Overrun");
  intr_register (10, 0, INTR_ON, panic, "#TS Invalid TSS Exception");
  intr_register (11, 0, INTR_ON, kill, "#NP Segment Not Present");
  intr_register (12, 0, INTR_ON, kill, "#SS Stack Fault Exception");
  intr_register (13, 0, INTR_ON, kill, "#GP General Protection Exception");
  intr_register (16, 0, INTR_ON, kill, "#MF x87 FPU Floating-Point Error");
  intr_register (17, 0, INTR_ON, panic, "#AC Alignment Check Exception");
  intr_register (18, 0, INTR_ON, panic, "#MC Machine-Check Exception");
  intr_register (19, 0, INTR_ON, kill, "#XF SIMD Floating-Point Exception");

  /* Most exceptions can be handled with interrupts turned on.
     We need to disable interrupts for page faults because the
     fault address is stored in CR2 and needs to be preserved. */
  intr_register (14, 0, INTR_OFF, kill, "#PF Page-Fault Exception");

  idtr_operand = make_dtr_operand (sizeof idt - 1, idt);
  asm volatile ("lidt %0" :: "m" (idtr_operand));
}

/* Registers interrupt VEC_NO to invoke HANDLER, which is named
   NAME for debugging purposes.  The interrupt handler will be
   invoked with interrupt status set to LEVEL.

   The handler will have descriptor privilege level DPL, meaning
   that it can be invoked intentionally when the processor is in
   the DPL or lower-numbered ring.  In practice, DPL==3 allows
   user mode to invoke the interrupts and DPL==0 prevents such
   invocation.  Faults and exceptions that occur in user mode
   still cause interrupts with DPL==0 to be invoked.  See
   [IA32-v3] sections 4.5 and 4.8.1.1 for further discussion. */
void
intr_register (uint8_t vec_no, int dpl, enum intr_level level,
               intr_handler_func *handler,
               const char *name) 
{
  /* Make sure this handler isn't already registered to someone
     else. */
  ASSERT (intr_handlers[vec_no] == NULL);

  /* Interrupts generated by external hardware (0x20 <= VEC_NO <=
     0x2f) should specify INTR_OFF for LEVEL.  Otherwise a timer
     interrupt could cause a task switch during interrupt
     handling.  Most other interrupts can and should be handled
     with interrupts enabled. */
  ASSERT (vec_no < 0x20 || vec_no > 0x2f || level == INTR_OFF);

  if (level == INTR_ON)
    idt[vec_no] = make_trap_gate (intr_stubs[vec_no], dpl);
  else
    idt[vec_no] = make_intr_gate (intr_stubs[vec_no], dpl);
  intr_handlers[vec_no] = handler;
  intr_names[vec_no] = name;
}

/* Returns true during processing of an external interrupt
   and false at all other times. */
bool
intr_context (void) 
{
  return in_external_intr;
}

/* During processing of an external interrupt, directs the
   interrupt handler to yield to a new process just before
   returning from the interrupt.  May not be called at any other
   time. */
void
intr_yield_on_return (void) 
{
  ASSERT (intr_context ());
  yield_on_return = true;
}

/* 8259A Programmable Interrupt Controller. */

/* Every PC has two 8259A Programmable Interrupt Controller (PIC)
   chips.  One is a "master" accessible at ports 0x20 and 0x21.
   The other is a "slave" cascaded onto the master's IRQ 2 line
   and accessible at ports 0xa0 and 0xa1.  Accesses to port 0x20
   set the A0 line to 0 and accesses to 0x21 set the A1 line to
   1.  The situation is similar for the slave PIC.

   By default, interrupts 0...15 delivered by the PICs will go to
   interrupt vectors 0...15.  Unfortunately, those vectors are
   also used for CPU traps and exceptions.  We reprogram the PICs
   so that interrupts 0...15 are delivered to interrupt vectors
   32...47 (0x20...0x2f) instead. */

/* Initializes the PICs.  Refer to [8259A] for details. */
static void
pic_init (void)
{
  /* Mask all interrupts on both PICs. */
  outb (0x21, 0xff);
  outb (0xa1, 0xff);

  /* Initialize master. */
  outb (0x20, 0x11); /* ICW1: single mode, edge triggered, expect ICW4. */
  outb (0x21, 0x20); /* ICW2: line IR0...7 -> irq 0x20...0x27. */
  outb (0x21, 0x04); /* ICW3: slave PIC on line IR2. */
  outb (0x21, 0x01); /* ICW4: 8086 mode, normal EOI, non-buffered. */

  /* Initialize slave. */
  outb (0xa0, 0x11); /* ICW1: single mode, edge triggered, expect ICW4. */
  outb (0xa1, 0x28); /* ICW2: line IR0...7 -> irq 0x28...0x2f. */
  outb (0xa1, 0x02); /* ICW3: slave ID is 2. */
  outb (0xa1, 0x01); /* ICW4: 8086 mode, normal EOI, non-buffered. */

  /* Unmask all interrupts. */
  outb (0x21, 0x00);
  outb (0xa1, 0x00);
}

/* Sends an end-of-interrupt signal to the PIC for the given IRQ.
   If we don't acknowledge the IRQ, it will never be delivered to
   us again, so this is important.  */
static void
pic_end_of_interrupt (int irq) 
{
  ASSERT (irq >= 0x20 && irq < 0x30);

  /* Acknowledge master PIC. */
  outb (0x20, 0x20);

  /* Acknowledge slave PIC if this is a slave interrupt. */
  if (irq >= 0x28)
    outb (0xa0, 0x20);
}

/* Creates an gate that invokes FUNCTION.

   The gate has descriptor privilege level DPL, meaning that it
   can be invoked intentionally when the processor is in the DPL
   or lower-numbered ring.  In practice, DPL==3 allows user mode
   to call into the gate and DPL==0 prevents such calls.  Faults
   and exceptions that occur in user mode still cause gates with
   DPL==0 to be invoked.  See [IA32-v3] sections 4.5 and 4.8.1.1
   for further discussion.

   TYPE must be either TYPE_INT_32 (for an interrupt gate) or
   TYPE_TRAP_32 (for a trap gate).  The difference is that
   entering an interrupt gate disables interrupts, but entering a
   trap gate does not.  See [IA32-v3] section 5.12.1.2 for
   discussion. */
static uint64_t
make_gate (void (*function) (void), int dpl, enum seg_type type)
{
  uint32_t offset = (uint32_t) function;
  uint32_t e0 = ((offset & 0xffff)            /* Offset 15:0. */
                 | (SEL_KCSEG << 16));        /* Target code segment. */
  uint32_t e1 = ((offset & 0xffff0000)        /* Offset 31:16. */
                 | (1 << 15)                  /* Present. */
                 | ((uint32_t) dpl << 13)     /* Descriptor privilege. */
                 | (SYS_SYSTEM << 12)         /* System. */
                 | ((uint32_t) type << 8));   /* Gate type. */
  return e0 | ((uint64_t) e1 << 32);
}

/* Creates an interrupt gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_intr_gate (void (*function) (void), int dpl)
{
  return make_gate (function, dpl, TYPE_INT_32);
}

/* Creates a trap gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_trap_gate (void (*function) (void), int dpl)
{
  return make_gate (function, dpl, TYPE_TRAP_32);
}

/* Interrupt handlers. */

static void dump_intr_frame (struct intr_frame *);

/* Handler for all interrupts, faults, and exceptions.  This
   function is called by the assembly language interrupt stubs in
   intr-stubs.S (see intr-stubs.pl).  ARGS describes the
   interrupt and the interrupted thread's registers. */
void
intr_handler (struct intr_frame *args) 
{
  bool external;
  intr_handler_func *handler;

  external = args->vec_no >= 0x20 && args->vec_no < 0x30;
  if (external) 
    {
      ASSERT (intr_get_level () == INTR_OFF);
      ASSERT (!intr_context ());

      in_external_intr = true;
      yield_on_return = false;
    }

  /* Invoke the interrupt's handler.
     If there is no handler, invoke the unexpected interrupt
     handler. */
  handler = intr_handlers[args->vec_no];
  if (handler == NULL)
    handler = panic;
  handler (args);

  /* Complete the processing of an external interrupt. */
  if (external) 
    {
      ASSERT (intr_get_level () == INTR_OFF);
      ASSERT (intr_context ());

      in_external_intr = false;
      pic_end_of_interrupt (args->vec_no); 

      if (yield_on_return) 
        thread_yield (); 
    }
}

/* Handler for an interrupt that should not have been invoked. */
static void
panic (struct intr_frame *regs) 
{
  dump_intr_frame (regs);
  PANIC ("Panic!");
}

/* Handler for an exception (probably) caused by a user process. */
static void
kill (struct intr_frame *f) 
{
  /* This interrupt is one (probably) caused by a user process.
     For example, the process might have tried to access unmapped
     virtual memory (a page fault).  For now, we simply kill the
     user process.  Later, we'll want to handle page faults in
     the kernel.  Real Unix-like operating systems pass most
     exceptions back to the process via signals, but we don't
     implement them. */
     
  /* The interrupt frame's code segment value tells us where the
     exception originated. */
  switch (f->cs)
    {
    case SEL_UCSEG:
      /* User's code segment, so it's a user exception, as we
         expected. */
      printk ("%s: dying due to interrupt %#04x (%s).\n",
              thread_name (thread_current ()),
              f->vec_no, intr_names[f->vec_no]);
      dump_intr_frame (f);
      thread_exit (); 

    case SEL_KCSEG:
      /* Kernel's code segment, which indicates a kernel bug.
         Kernel code shouldn't throw exceptions.  (Page faults
         may cause kernel exceptions--but they shouldn't arrive
         here.) */
      printk ("Kernel bug - unexpected interrupt in kernel\n");
      panic (f);

    default:
      /* Some other code segment?  Shouldn't happen. */
      printk ("Interrupt %#04x (%s) in unknown segment %04x\n",
             f->vec_no, intr_names[f->vec_no], f->cs);
      thread_exit ();
    }
}

/* Dumps interrupt frame F to the console, for debugging. */
static void
dump_intr_frame (struct intr_frame *f) 
{
  uint32_t cr2, ss;
  asm ("movl %%cr2, %0" : "=r" (cr2));
  asm ("movl %%ss, %0" : "=r" (ss));

  printk ("Interrupt %#04x (%s) at eip=%p\n",
          f->vec_no, intr_names[f->vec_no], f->eip);
  printk (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
  printk (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
          f->eax, f->ebx, f->ecx, f->edx);
  printk (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
  printk (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
          f->cs, f->ds, f->es, f->cs != SEL_KCSEG ? f->ss : ss);
}

